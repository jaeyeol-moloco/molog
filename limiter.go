package molog

import (
	"fmt"
	"math/rand"
	"runtime"
	"strings"
	"sync/atomic"
	"time"

	ccache "github.com/karlseguin/ccache/v2"
)

// Limiter can be applied to a logger and used to limit log entries by its purpose
// such as sampling or deduplication.
type Limiter interface {
	Allow(entry *Entry) bool
}

// AndLimiters returns a new Limiter that concatenates the given limiters with
// AND. In other words, the returned Limiter allows a log entry only if all the
// given limiters allow the log entry.
func AndLimiters(first, second Limiter, others ...Limiter) *andLimiter {
	limiters := append([]Limiter{first, second}, others...)
	return &andLimiter{
		limiters: limiters,
	}
}

type andLimiter struct {
	limiters []Limiter
}

func (a *andLimiter) Allow(entry *Entry) bool {
	for _, limiter := range a.limiters {
		if !limiter.Allow(entry) {
			return false
		}
	}
	return true
}

// NewBasicSampler creates a Limiter that samples the first entry, then every nth entry thereafter.
func NewBasicSampler(n uint32) *basicSampler {
	return &basicSampler{
		n: n,
	}
}

type basicSampler struct {
	n       uint32
	counter uint32
}

func (s *basicSampler) Allow(_ *Entry) bool {
	n := s.n
	if n == 1 {
		return true
	}
	c := atomic.AddUint32(&s.counter, 1)
	return c%n == 1
}

// NewRandomSampler creates a Limiter that samples log entries randomly at the given rate.
func NewRandomSampler(rate float64) *randomSampler {
	return &randomSampler{
		rate: rate,
	}
}

type randomSampler struct {
	rate float64
}

func (s *randomSampler) Allow(_ *Entry) bool {
	return rand.Float64() < s.rate
}

var cache = ccache.New(ccache.Configure().MaxSize(1000))

// Deduper distinguishes log entries by its log key generated by LogKeyGen and deduplicates
// entries with the same key during CoolingTimeSeconds.
type Deduper struct {
	CoolingTimeSeconds uint32
	LogKeyGen          func(*Entry) string
}

func (d *Deduper) Allow(entry *Entry) bool {
	key := d.LogKeyGen(entry)
	item := cache.Get(key)
	if item == nil || item.Expired() {
		cache.Set(key, "", time.Duration(d.CoolingTimeSeconds)*time.Second)
		return true
	}
	return false
}

// NewDeduperByCaller creates a Deduper which deduplicates logs by location of logging,
// which consists of the source file name and the line number.
func NewDeduperByCaller(coolingTimeSeconds uint32) *Deduper {
	return &Deduper{
		CoolingTimeSeconds: coolingTimeSeconds,
		LogKeyGen:          callerLogKey,
	}
}

func callerLogKey(_ *Entry) string {
	pc := make([]uintptr, 8)
	// Skips 4 frames:
	// 0: callers() in runtime/extern.go <- must be skipped
	// 1: Callers() in callerLogKey
	// 2: LogKeyGen() in *Deduper.Allow func
	// 3: Allow() in *Entry.Log
	// 4: can be external or molog internal call <- start here
	n := runtime.Callers(4, pc)
	frames := runtime.CallersFrames(pc[:n])
	for {
		f, ok := frames.Next()
		if !ok {
			break
		}
		// Finds the first external function call
		if !strings.HasPrefix(f.Function, "github.com/moloco/molog.") {
			return fmt.Sprintf("%s:%d", f.File, f.Line)
		}
	}
	return ""
}
